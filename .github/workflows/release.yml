name: Release

on:
  workflow_dispatch:

concurrency: release

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For git operations and GitHub releases
      id-token: write  # For PyPI OIDC publishing

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@v7

      - name: Set up Python
        run: uv python install 3.12

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24

      - name: Install dependencies
        run: |
          uv sync --all-packages
          npm install

      - name: Check if release is needed
        id: check_release
        run: |
          # Check if there are no existing tags (first release)
          if [ -z "$(git tag -l)" ]; then
            echo "release_needed=true" >> $GITHUB_OUTPUT
            echo "reason=first_release" >> $GITHUB_OUTPUT
          else
            # Check semantic release and capture next version
            NEXT_VERSION=$(uv run semantic-release --noop version --print 2>/dev/null)
            if [ $? -eq 0 ] && [ -n "$NEXT_VERSION" ]; then
              echo "release_needed=true" >> $GITHUB_OUTPUT
              echo "reason=conventional_commits" >> $GITHUB_OUTPUT
              echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
            else
              echo "release_needed=false" >> $GITHUB_OUTPUT
              echo "reason=no_changes" >> $GITHUB_OUTPUT
            fi
          fi

      - name: No Release Needed
        if: steps.check_release.outputs.release_needed == 'false'
        run: |
          echo "â„¹ï¸ No release needed - no significant commits since last release"
          echo "To trigger a release, make commits with conventional commit messages:"
          echo "  feat: for new features (minor version bump)"
          echo "  fix: for bug fixes (patch version bump)"
          echo "  feat: with BREAKING CHANGE: for breaking changes (major version bump)"

      - name: Get current version info
        if: steps.check_release.outputs.release_needed == 'true'
        id: version_info
        run: |
          CURRENT_VERSION=$(grep 'version = ' pyproject.toml | head -1 | sed 's/.*version = "\([^"]*\)".*/\1/')
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT

          # Set next version based on release reason
          if [ "${{ steps.check_release.outputs.reason }}" = "conventional_commits" ]; then
            # Use the next_version already captured in check_release step
            echo "next_version=${{ steps.check_release.outputs.next_version }}" >> $GITHUB_OUTPUT
          else
            # For first_release or any other case, use current version
            echo "next_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Lint code
        if: steps.check_release.outputs.release_needed == 'true'
        run: uv run poe lint

      - name: Typecheck code
        if: steps.check_release.outputs.release_needed == 'true'
        run: uv run poe typecheck

      - name: Run tests
        if: steps.check_release.outputs.release_needed == 'true'
        run: uv run poe test

      - name: Show release plan
        if: steps.check_release.outputs.release_needed == 'true'
        run: |
          echo "ðŸ“‹ RELEASE PLAN"
          echo "Current Version: ${{ steps.version_info.outputs.current_version }}"
          echo "Next Version: ${{ steps.version_info.outputs.next_version }}"
          echo "Release Reason: ${{ steps.check_release.outputs.reason }}"
          echo ""
          echo "ðŸ” Commits since last release:"
          if [ -n "$(git tag -l)" ]; then
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -n "$LAST_TAG" ]; then
              git log ${LAST_TAG}..HEAD --oneline --pretty=format:"- %s (%h)"
            else
              echo "- No previous tags found"
            fi
          else
            echo "- First release (no previous tags)"
          fi

      - name: Semantic Release
        if: steps.check_release.outputs.release_needed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸš€ Creating alpha release..."

          # Get current version
          CURRENT_VERSION=$(grep 'version = ' pyproject.toml | head -1 | sed 's/.*version = "\([^"]*\)".*/\1/')

          # Increment alpha counter
          if [[ "$CURRENT_VERSION" =~ 1\.0\.0-alpha\.([0-9]+) ]]; then
            ALPHA_NUM=$((${BASH_REMATCH[1]} + 1))
          else
            ALPHA_NUM=1
          fi
          NEW_VERSION="1.0.0-alpha.$ALPHA_NUM"

          echo "Bumping from $CURRENT_VERSION to $NEW_VERSION"

          # Update version in all pyproject.toml files
          sed -i "s/version = \"$CURRENT_VERSION\"/version = \"$NEW_VERSION\"/" pyproject.toml
          for pkg in packages/*/pyproject.toml; do
            sed -i "s/version = \"$CURRENT_VERSION\"/version = \"$NEW_VERSION\"/" "$pkg"
          done

          # Commit and tag
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add pyproject.toml packages/*/pyproject.toml
          git commit -m "chore(release): $NEW_VERSION"
          git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION"
          git push origin main --tags

      - name: Get released version
        if: steps.check_release.outputs.release_needed == 'true'
        id: released_version
        run: |
          RELEASED_VERSION=$(grep 'version = ' pyproject.toml | head -1 | sed 's/.*version = "\([^"]*\)".*/\1/')
          echo "version=$RELEASED_VERSION" >> $GITHUB_OUTPUT
          echo "Released version: $RELEASED_VERSION"

      - name: Build packages
        if: steps.check_release.outputs.release_needed == 'true'
        run: |
          echo "ðŸ“¦ Building all packages..."
          uv build --all-packages

      - name: Show build artifacts
        if: steps.check_release.outputs.release_needed == 'true'
        run: |
          echo "ðŸ“¦ Built artifacts:"
          ls -la dist/

      - name: Create GitHub Release
        if: steps.check_release.outputs.release_needed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ðŸš€ Creating GitHub release..."
          VERSION=${{ steps.released_version.outputs.version }}
          CHANGELOG_CONTENT="$(sed -n '/^## v'$VERSION'/,/^## /p' CHANGELOG.md 2>/dev/null | sed '$d')"
          if [ -z "$CHANGELOG_CONTENT" ]; then
            CHANGELOG_CONTENT="Release v$VERSION"
          fi

          gh release create "v$VERSION" \
            --title "Release v$VERSION" \
            --notes "$CHANGELOG_CONTENT" \
            dist/*.whl dist/*.tar.gz

      - name: Publish to PyPI
        if: steps.check_release.outputs.release_needed == 'true'
        uses: pypa/gh-action-pypi-publish@release/v1

      - name: Release Summary
        if: steps.check_release.outputs.release_needed == 'true'
        run: |
          echo "ðŸŽ‰ RELEASE COMPLETED"
          echo "Released version: ${{ steps.released_version.outputs.version }}"
          echo "Published to PyPI: âœ“"
          echo "GitHub release created: âœ“"
          echo "Changelog updated: âœ“"
          echo "Reason: ${{ steps.check_release.outputs.reason }}"
